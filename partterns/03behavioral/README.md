适配器、代理和门面模式，它们似乎真的给我的感觉是相同的，这主要是因为在运行时的关系是非常类似的：

代理与适配器模式比较

    代理模式更改服务的行为，但保留其接口。
    适配器模式改变服务接口，但保留它的行为。
    客户端可以相同的方式使用代理或服务实体。
    设计用于适配器的客户端将不能使用没有它的服务实体。
    代理可以转换为服务接口；适配器可转换为客户端期望的接口。

适配器与门面模式比较

    适配器 用来维护现有的多态性。换言之，欲适配的接口可能已经存在，并可能已经发挥作用。
    门面 提供一个比较理想化的接口，但它可以逐步开发发展，作为新的子系统需求发现。
    适配器 通常都很小，因此一般不会出现性能的关注。
    门面往往要较大，因此它可能是有用的，以确保是可重入的（以避免多个实例需要） 。
    “适配者（Adaptee）”可能很好，如其所述，之所以使用适配器，是因已经承担另一不同接口的责任。
    “门面者（Facadee）”可能不如其所述，正与其它开发者使用“门面”通讯。

代理与门面模式比较

    代理 是可选的，门面通常不会 。
    代理的目的是添加行为，门面的目的是为了简化，实际上可能涉及删减行为。


adapter, facade, proxy之所以要一起说，是因为他们都设计对另外一个对象的包装。实际情况中，到不用刻意去使用那种，因为这不是由使用者决定的，而是它们本身的适用场景和当时的上下文决定的。（后一句好像是废话，哪一种设计模式不是呢，与其说是我们选择了设计模式，倒不如说是需求和环境自己的选择）

下面说这3种模式，都是包装，差别究竟有何不同？

Adapter:  针对特定接口对现存类进行包装。
特点：   接口是定死的，意味着你要实现接口的所有功能 。
               现存类在这里是不可修改的。
               一般用于多态的场景，实现接口的子类包装另外一个对象。
关键词： 匹配


facade:  对一组相互协作的类或一个子系统包装成一个简化规范的接口。
特点：   接口不是固定的，是自己定义的，当然原则是应尽量简化
              把子系统要完全隐藏。使用它得人只能看到facade。
              目的在于，“编写一个新的类”的代价远远低于让所有的人都学会使用原有系统。
              典型的逻辑分离。让我们的注意力集中到我们需要化功夫处理的逻辑层而不被其他的逻辑层干扰。（究竟什么逻辑层呢，何以界定高低？ 以后写，呵呵）
关键词：简化，分层

proxy：本来先不打算写它，但是facade的分层包装的说法让我想到还有一个proxy，他们区别在何处？
特点：  先说说几种常用的proxy
              远程proxy ,真正的对象在远程机器或远程的地址空间(Web Service ?)
              虚拟代理，真正的对象使用代价过高。比如需要权限验证，耗用资源，或者根本还未创建而现阶段需要使用的对象。
              保护代理，需要对真正的对象提供级别不同的访问
可以看出，这几种代理，简而言之将复杂的使用对象简化了。简化的不是接口方法，而是获取或使用对象的途径。
与facade的区别：facade一般代表一组对象或一个字系统
                              proxy代表单一对象
                              facade自定义接口，proxy 有与被代理对象相同接口
                               facade 简化接口
                                proxy 控制使用对象的使用级别或者使用成本（对于虚拟代理而言）。



#策略模式和工厂模式的区别

工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；而策略模式是行为型的，它接受已经创建好的实例，实现不同的行为。
装饰模式、代理模式、外观模式、适配器模式的区别

概念
适配器模式：一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。

装饰器模式：原有的不能满足现有的需求，对原有的进行增强。

代理模式：同一个类而去调用另一个类的方法，不对这个方法进行直接操作

外观模式：我们通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。

区别
代理模式是与原对象实现同一个接口，必须要实现原接口和持有真实的对象，才能称之为代理类。代理模式一定是自身持有这个对象，不需要从外部传入。用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。

装饰模式的一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意挑换顺序。当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

适配器类则是匹配新接口，从代码上的特点来说，适配类持有新的目标对象（对象适配器）。

代理模式注重的是隔离限制，关注于控制对对象的访问，让外部不能访问你实际的调用对象，比如权限控制。代理和真实对象之间的的关系通常在编译时就已经确定了。

装饰模式注重的是功能的拓展，关注于在一个对象上动态的添加方法，在同一个方法下实现更多的功能。装饰者能够在运行时递归地被构造。

适配器模式注重的是接口的兼容。

外观模式注重的是多个类的集成、统一适配。
装饰模式和代理模式的区别

装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
外观模式和代理模式的区别

代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统，代理的客户对象无法直接访问对象，由代理提供单独的目标对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉的。
外观模式和适配器模式的区别

外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，外观所针对的对象的粒度更大。
适配器模式和代理模式的区别

适配器模式改变所考虑的对象的接口，代理模式不能改变所代理对象的接口。